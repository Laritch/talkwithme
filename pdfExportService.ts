import jsPDF from 'jspdf';
import html2canvas from 'html2canvas';

// Types
export interface ChatMessage {
  id: string;
  sender: {
    id: string;
    name: string;
    avatar?: string;
    role?: string;
  };
  content: string;
  timestamp: string | Date;
  attachments?: Array<{
    id: string;
    url: string;
    type: string;
    name: string;
  }>;
}

export interface ChatExportOptions {
  title?: string;
  includeTimestamps?: boolean;
  includeAttachments?: boolean;
  dateFormat?: string;
  orientation?: 'portrait' | 'landscape';
  pageSize?: string;
  headerLogo?: string;
  footerText?: string;
  includeUserInfo?: boolean;
  theme?: 'light' | 'dark';
}

// Default options for PDF export
const defaultOptions: ChatExportOptions = {
  title: 'Chat Transcript',
  includeTimestamps: true,
  includeAttachments: true,
  dateFormat: 'MMM DD, YYYY HH:mm',
  orientation: 'portrait',
  pageSize: 'a4',
  footerText: 'Generated by Instructor Chat System',
  includeUserInfo: true,
  theme: 'light',
};

/**
 * Formats a date based on the provided format string
 * This is a very simple implementation, in real app use a library like date-fns or luxon
 */
function formatDate(date: Date | string, format = 'MMM DD, YYYY HH:mm'): string {
  const d = typeof date === 'string' ? new Date(date) : date;

  if (isNaN(d.getTime())) {
    return 'Invalid date';
  }

  const months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
  const year = d.getFullYear();
  const month = months[d.getMonth()];
  const day = d.getDate().toString().padStart(2, '0');
  const hours = d.getHours().toString().padStart(2, '0');
  const minutes = d.getMinutes().toString().padStart(2, '0');

  return format
    .replace('YYYY', year.toString())
    .replace('MMM', month)
    .replace('DD', day)
    .replace('HH', hours)
    .replace('mm', minutes);
}

/**
 * Generates PDF from an HTML element
 */
export async function generatePdfFromElement(
  element: HTMLElement,
  options: ChatExportOptions = {}
): Promise<jsPDF> {
  // Merge default options with provided options
  const mergedOptions = { ...defaultOptions, ...options };

  // Create PDF document
  const pdf = new jsPDF({
    orientation: mergedOptions.orientation,
    unit: 'mm',
    format: mergedOptions.pageSize,
  });

  // Set PDF properties
  pdf.setProperties({
    title: mergedOptions.title || 'Chat Transcript',
    subject: 'Chat Transcript Export',
    author: 'Instructor Chat System',
    creator: 'Instructor Chat System',
  });

  // Create canvas from HTML element
  const canvas = await html2canvas(element, {
    scale: 2,
    useCORS: true, // Enable CORS for images
    allowTaint: true,
    backgroundColor: mergedOptions.theme === 'dark' ? '#1a202c' : '#ffffff',
  });

  // Add canvas image to PDF
  const imgData = canvas.toDataURL('image/png');
  const pdfWidth = pdf.internal.pageSize.getWidth();
  const pdfHeight = pdf.internal.pageSize.getHeight();
  const imgWidth = canvas.width;
  const imgHeight = canvas.height;
  const ratio = Math.min(pdfWidth / imgWidth, pdfHeight / imgHeight);
  const imgX = (pdfWidth - imgWidth * ratio) / 2;

  pdf.addImage(imgData, 'PNG', imgX, 10, imgWidth * ratio, imgHeight * ratio);

  // Add footer
  if (mergedOptions.footerText) {
    const footerFontSize = 10;
    pdf.setFontSize(footerFontSize);
    pdf.setTextColor(100, 100, 100);
    pdf.text(
      mergedOptions.footerText,
      pdfWidth / 2,
      pdfHeight - 10,
      { align: 'center' }
    );
  }

  return pdf;
}

/**
 * Exports chat messages as a PDF file
 */
export async function exportChatAsPdf(
  messages: ChatMessage[],
  options: ChatExportOptions = {}
): Promise<jsPDF> {
  // Merge default options with provided options
  const mergedOptions = { ...defaultOptions, ...options };

  // Create PDF document
  const pdf = new jsPDF({
    orientation: mergedOptions.orientation,
    unit: 'mm',
    format: mergedOptions.pageSize,
  });

  // Set PDF properties
  pdf.setProperties({
    title: mergedOptions.title || 'Chat Transcript',
    subject: 'Chat Transcript Export',
    author: 'Instructor Chat System',
    creator: 'Instructor Chat System',
  });

  // Add title
  const titleFontSize = 18;
  pdf.setFontSize(titleFontSize);
  pdf.setTextColor(0, 0, 0);
  pdf.text(mergedOptions.title || 'Chat Transcript', 14, 20);

  // Add export date
  const dateFontSize = 10;
  pdf.setFontSize(dateFontSize);
  pdf.setTextColor(100, 100, 100);
  pdf.text(
    `Exported on: ${formatDate(new Date(), mergedOptions.dateFormat)}`,
    14,
    30
  );

  // Add messages
  const messageFontSize = 11;
  const infoFontSize = 9;
  let yPos = 40;
  const pageWidth = pdf.internal.pageSize.getWidth();
  const pageHeight = pdf.internal.pageSize.getHeight();
  const margin = 14;
  const maxLineWidth = pageWidth - 2 * margin;

  // Process each message
  for (const message of messages) {
    // Check if we need a new page
    if (yPos > pageHeight - 30) {
      pdf.addPage();
      yPos = 20;
    }

    // Add sender info
    pdf.setFontSize(infoFontSize);
    pdf.setTextColor(50, 50, 50);
    pdf.text(
      `${message.sender.name}${message.sender.role ? ` (${message.sender.role})` : ''}`,
      margin,
      yPos
    );

    // Add timestamp if required
    if (mergedOptions.includeTimestamps) {
      const timestamp = formatDate(message.timestamp, mergedOptions.dateFormat);
      pdf.setFontSize(infoFontSize);
      pdf.setTextColor(150, 150, 150);
      pdf.text(timestamp, pageWidth - margin, yPos, { align: 'right' });
    }

    yPos += 5;

    // Add message content
    pdf.setFontSize(messageFontSize);
    pdf.setTextColor(0, 0, 0);

    // Split text into lines to fit within page width
    const textLines = pdf.splitTextToSize(message.content, maxLineWidth);

    // Add each line to the PDF
    for (const line of textLines) {
      // Check if we need a new page
      if (yPos > pageHeight - 30) {
        pdf.addPage();
        yPos = 20;
      }

      pdf.text(line, margin, yPos);
      yPos += 6;
    }

    // Add attachments if required
    if (mergedOptions.includeAttachments && message.attachments && message.attachments.length > 0) {
      pdf.setFontSize(infoFontSize);
      pdf.setTextColor(100, 100, 100);
      pdf.text('Attachments:', margin, yPos);
      yPos += 5;

      for (const attachment of message.attachments) {
        pdf.text(`- ${attachment.name} (${attachment.type})`, margin + 5, yPos);
        yPos += 5;
      }
    }

    // Add space between messages
    yPos += 10;
  }

  // Add footer
  if (mergedOptions.footerText) {
    const footerFontSize = 10;
    pdf.setFontSize(footerFontSize);
    pdf.setTextColor(100, 100, 100);
    pdf.text(
      mergedOptions.footerText,
      pageWidth / 2,
      pageHeight - 10,
      { align: 'center' }
    );
  }

  return pdf;
}

/**
 * Downloads the generated PDF
 */
export function downloadPdf(pdf: jsPDF, filename = 'chat-transcript.pdf'): void {
  pdf.save(filename);
}

/**
 * Opens the PDF in a new tab
 */
export function openPdfInNewTab(pdf: jsPDF): void {
  const pdfBlob = pdf.output('blob');
  const pdfUrl = URL.createObjectURL(pdfBlob);
  window.open(pdfUrl, '_blank');
}

/**
 * Main function to export chats - handles the full workflow
 */
export async function exportChatTranscript(
  messages: ChatMessage[],
  options: ChatExportOptions = {},
  action: 'download' | 'open' = 'download'
): Promise<void> {
  const pdf = await exportChatAsPdf(messages, options);

  if (action === 'download') {
    downloadPdf(pdf, `${options.title || 'chat-transcript'}.pdf`);
  } else {
    openPdfInNewTab(pdf);
  }
}
